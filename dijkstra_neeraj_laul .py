# -*- coding: utf-8 -*-
"""dijkstra_neeraj_laul.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qKk7XYcVDakQ8MNjKbqv9pmXH4d_fuw2
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import matplotlib.pyplot as plt
import cv2

# Path to save the map image
map_path = '/content/drive/MyDrive/ENPM661/'

# Define canvas dimensions
canvas_length = 1200
canvas_width = 500

# Create canvas
canvas = np.zeros((canvas_width, canvas_length))

# Function to draw a rectangle on the canvas
def draw_rectangle(canvas, x, y, width, height, color=255):
    # Draw the rectangle
    canvas[y:y+height, x:x+width] = color

# Function to draw a hexagon on the canvas
def draw_hexagon(canvas, center_x, center_y, side_length, color=255):
    # Calculate vertices of the hexagon
    angles = np.linspace(np.pi / 6, 2 * np.pi + np.pi / 6, 7)[:-1]  # Angles for hexagon vertices
    x = center_x + side_length * np.cos(angles)
    y = center_y + side_length * np.sin(angles)
    vertices = np.column_stack((x, y)).astype(int)

    # Draw the hexagon
    cv2.fillPoly(canvas, [vertices], color)

# Define obstacle 1
draw_rectangle(canvas, 100, 0, 75, 400)

# Define obstacle 2
draw_rectangle(canvas, 275, 100, 75, 400)

# Define obstacle 3 (hexagon)
draw_hexagon(canvas, 650, 250, 150)

# Define obstacle 4 part 1
draw_rectangle(canvas, 900, 50, 200, 75)

# Define obstacle 4 part 2
draw_rectangle(canvas, 1020, 50, 80, 400)

# Define obstacle 4 part 3
draw_rectangle(canvas, 900, 375, 200, 75)

# Plot canvas with y-axis increasing upwards
plt.imshow(canvas, cmap='gray')
plt.title('Map with Obstacles 1, 2, 3, and 4 without Padding')
plt.xlabel('X')
plt.ylabel('Y')
plt.show()

# Save the canvas without altering color mappings
cv2.imwrite(map_path + 'map_path.jpg', canvas)

"""This is the code to create the map required for the dikstra algorithm to read. I experimented with other map techniques and found this one to be the most optimal. There is also another way I have tried to do it, by using the map image given in the project powerpoint and then using opencv to apply thresholding and edge detection. I did not use that method as the project guidelines mentioned actually creating the map, but I have included the code for my other method in the file and commented it out.

This code uses matplotlib and basic shapes to draw the obstacles. I wanted the obstacles to be black in the generated canvas, but that led to some saving issues in this code and I elected to invert the map in the actual dijkstra code instead.
"""

import numpy as np
import cv2
import heapq
import matplotlib.pyplot as plt
import os

# Define the order of movement (up, right, down, left, diagonal)
movement_order = [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (-1, 1), (1, -1), (-1, -1)]

# Define a class to represent nodes in the grid
class Node:
    def __init__(self, x, y, cost):
        self.x = x  # X coordinate of the node
        self.y = y  # Y coordinate of the node
        self.cost = cost  # Cost associated with reaching this node

    def __lt__(self, other):
        return self.cost < other.cost  # Comparison method for priority queue ordering

# Function to get neighboring nodes of a given node
def get_neighbors(node, grid, padding_thickness):
    neighbors = []
    height, width = grid.shape

    # Iterate through all possible movements
    for dx, dy in movement_order:
        new_x, new_y = node.x + dx, node.y + dy
        # Check if the new position is within the padded boundaries
        if padding_thickness <= new_x < height - padding_thickness and padding_thickness <= new_y < width - padding_thickness:
            neighbors.append(Node(new_x, new_y, 0))  # Add the valid neighbor to the list

    return neighbors

# Function to read the map from a file
def read_map_from_file(image_path):
    try:
        # Read the image file and convert it to a grayscale grid
        grid1 = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
        if grid1 is None:
            raise ValueError("Failed to read image file")
        grid = cv2.bitwise_not(grid1)  # Invert the colors to represent obstacles as black
        return grid
    except Exception as e:
        print("Error reading image file:", e)
        return None

# Function to add padding around obstacles in the grid
def add_padding_to_obstacles(grid, padding_size):
    padded_grid = np.copy(grid)  # Create a copy of the original grid
    height, width = grid.shape

    # Iterate through each cell in the grid
    for x in range(height):
        for y in range(width):
            if grid[x, y] == 0:  # Check if the cell represents an obstacle (black pixel)
                # Iterate through the cells in the padding region around the obstacle
                for i in range(-padding_size, padding_size + 1):
                    for j in range(-padding_size, padding_size + 1):
                        new_x, new_y = x + i, y + j  # Calculate the position of the padded cell
                        # Check if the new position is within the grid boundaries
                        if 0 <= new_x < height and 0 <= new_y < width:
                            padded_grid[new_x, new_y] = 0  # Mark the padded cell as an obstacle

    return padded_grid

# Function to visualize the explored nodes on the grid
def visualize_explored_nodes(grid, explored_nodes, start, goal, save_path='/content/drive/MyDrive/ENPM661/Outputs/SavedImages'):
    plt.imshow(grid, cmap='gray')  # Display the grid as an image
    plt.scatter(start.x, start.y, color='green', label='Start Node', s=100, marker='o')  # Visualize the start node
    plt.scatter(goal[0], goal[1], color='red', label='Goal Node', s=100, marker='x')  # Visualize the goal node
    explored_nodes = np.array(list(explored_nodes))
    plt.scatter(explored_nodes[:, 1], explored_nodes[:, 0], color='blue', label='Explored Nodes', alpha=0.3)  # Visualize the explored nodes with some transparency
    plt.title("Map with Explored Nodes")  # Set the title of the plot

# Dijkstra's algorithm for pathfinding
def dijkstra(grid, start, goal, padding_thickness):
    open_list = []  # Priority queue to store nodes to be explored
    closed_set = set()  # Set to store nodes that have been visited
    heapq.heappush(open_list, start)  # Add the start node to the priority queue
    explored_nodes = set()  # Set to store explored nodes
    parent_map = {}  # Dictionary to store parent-child relationships
    goal_node = None  # Variable to store the goal node

    # Main loop of Dijkstra's algorithm
    while open_list and not goal_node:
        current_node = heapq.heappop(open_list)  # Get the node with the lowest cost from the priority queue

        if (current_node.x, current_node.y) in closed_set:
            continue  # Skip this node if it has already been visited

        closed_set.add((current_node.x, current_node.y))  # Mark the current node as visited
        explored_nodes.add((current_node.x, current_node.y))  # Add the current node to the set of explored nodes

        # Check if the current node is the goal node
        if current_node.x == goal[0] and current_node.y == goal[1]:
            goal_node = current_node  # Set the goal node and exit the loop
            break

        # Explore neighboring nodes
        for neighbor in get_neighbors(current_node, grid, padding_thickness):
            neighbor_x, neighbor_y = neighbor.x, neighbor.y  # Get the coordinates of the neighbor node
            new_cost = current_node.cost + 1  # Calculate the cost to reach the neighbor node

            # Check if the neighbor node is not in the closed set and is not an obstacle
            if (neighbor_x, neighbor_y) not in closed_set and grid[neighbor_x, neighbor_y] != 0:
                # Update the parent-child relationship if necessary
                if (neighbor_x, neighbor_y) in parent_map:
                    if new_cost < parent_map[(neighbor_x, neighbor_y)].cost:
                        parent_map[(neighbor_x, neighbor_y)] = current_node
                else:
                    parent_map[(neighbor_x, neighbor_y)] = current_node

                heapq.heappush(open_list, Node(neighbor_x, neighbor_y, new_cost))  # Add the neighbor node to the priority queue

    return explored_nodes, goal_node, parent_map  # Return the explored

# Function to backtrack the optimal path from the goal node to the start node
def backtrack_path(goal_node, parent_map):
    current_node = goal_node  # Start from the goal node
    path = []  # List to store the path

    # Iterate through the parent-child relationships until reaching the start node
    while current_node:
        path.append((current_node.x, current_node.y))  # Add the current node to the path
        parent_node = parent_map.get((current_node.x, current_node.y), None)  # Get the parent node
        current_node = parent_node  # Move to the parent node

    path.reverse()  # Reverse the path to start from the start node
    return path  # Return the optimal path

# Function to visualize the path on the grid
def visualize_path(grid, explored_nodes, path, start, goal, save_path='/content/drive/MyDrive/ENPM661/Outputs/SavedImages', interval=None):
    plt.imshow(grid, cmap='gray')  # Display the grid as an image
    plt.scatter(start[1], start[0], color='green', label='Start Node', s=100, marker='o')  # Visualize the start node
    plt.scatter(goal[1], goal[0], color='red', label='Goal Node', s=100, marker='x')  # Visualize the goal node
    explored_nodes = np.array(list(explored_nodes))
    plt.scatter(explored_nodes[:, 1], explored_nodes[:, 0], color='blue', label='Explored Nodes')  # Visualize the explored nodes

    # Plot the optimal path if it exists
    if path:
        path = np.array(path)
        plt.plot(path[:, 1], path[:, 0], color='yellow', linewidth=2, label='Optimal Path')

    plt.title("Map with Explored Nodes and Optimal Path")  # Set the title of the plot
    plt.show()  # Show the plot

    # Save the plot as an image if a save path is provided
    if save_path and interval:
        plt.savefig(save_path)  # Save the plot as an image
        if interval > 0:
            plt.close()  # Close the plot window after saving

    # Save the path coordinates to a text file
    if save_path:
        path_file = os.path.splitext(save_path)[0] + "_path.txt"  # Generate the path file name
        with open(path_file, 'w') as f:
            for node in path:
                f.write(f"{node[0]} {node[1]}\n")  # Write each node's coordinates to the file
        print(f"Saved path coordinates to: {path_file}")  # Print a message indicating that the path coordinates have been saved
    print(explored_nodes)
    plt.show()  # Show the plot

# Main function to execute the pathfinding algorithm
def main(start_x, start_y, goal_x, goal_y):
    image_path = "/content/drive/MyDrive/ENPM661/map_path.jpg"  # Path to the image file containing the map
    grid = read_map_from_file(image_path)  # Read the map from the image file

    padding_size = 5  # Padding size to add around obstacles
    padded_grid = add_padding_to_obstacles(grid, padding_size)  # Add padding to the obstacles in the grid

    start = Node(start_x, start_y, 0)  # Create a start node object
    goal = (goal_x, goal_y)  # Define the goal coordinates

    # Run Dijkstra's algorithm to find the optimal path
    explored_nodes, goal_node, parent_map = dijkstra(padded_grid, start, goal, padding_size)

    # Check if a path to the goal node exists
    if goal_node:
        optimal_path = backtrack_path(goal_node, parent_map)  # Backtrack the optimal path
        # Visualize the map with explored nodes and the optimal path
        visualize_path(grid, explored_nodes, optimal_path, (start_x, start_y), goal, save_path="/content/drive/MyDrive/ENPM661/Outputs/SavedImages")
    else:
        print("No path found!")  # Print a message if no path to the goal node is found

# Entry point of the program
if __name__ == "__main__":
    # Get the start and goal coordinates from the user
    start_x, start_y = map(int, input("Enter start Y and X coordinates: ").split())
    goal_x, goal_y = map(int, input("Enter goal Y and X coordinates: ").split())
    main(start_x, start_y, goal_x, goal_y)  # Call the main function with the provided coordinates

"""This code block uses the map generated ny the earlier code block, and processes it using djikstra algorithm to find the neighbors by the defined action set, and then using backtracking to generate the optimum path. The code then saves the optimum path to the folder in my drive to see the nodes easily.
[Output Path](https://drive.google.com/file/d/1qwTs449w4kvpCPi7tAW03fGQh99oQbUi/view?usp=sharing)
"""

